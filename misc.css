/* This was the css for misc.html that took on a different design concept */

*, *::before, *::after {    
  box-sizing: border-box;   
}                           
/* By default, the box-sizing property is set to content-box, which means the 
width and height you specify apply only to the content area — padding and borders 
are added on top, making the total box larger. The border-box value includes the 
padding and border inside the specified width and height, making layout calculations 
easier. The ::before and ::after pseudo-elements are included so that no elements are missed.*/

html, body {
    height: 100%; /* Height needs to be added because min-height does not make the parent’s height definite. */
    min-height: 100dvh; /* Ensures it can grow with the viewport and remain flexible on mobile browsers. 
                        If you remove min-height, the layout will still work fine in most desktop browsers,
                        but you might see gaps or scroll issues when the browser UI changes size. */
    margin: 0;
}

.main-container {
    height: 100%;
    min-height: calc(100% - 2rem);
    padding-block: 1rem;  /* The top margin of the first child collapses with the parent’s top edge in a 
                          normal block layout flow, so I added padding instead to create some cushion at 
                          the top and make the content box centered on all sides. padding-block sets the padding 
                          for the top and bottom, while padding-inline sets it for the left and right 
                          (for example: padding-inline: ...) */
    padding-inline: 2%; 
    display: flex;
    flex-direction: column;
    background-color: #EAF2E9;
}

header, nav {
    position: relative;
    z-index:10;
}

header{
    block-size: clamp(88px, 10%, 140px); /* block-size is the same as height. The clamp() function combines 
                                         minimum, preferred, and maximum height values into a single responsive 
                                         expression.*/
    border: .50px solid #89D6BB;
    background-color: rgba(137, 214, 187, 0.65);
}

#logo {
    height: 100%;
    width: auto;
    display: block; /* Makes the image a block-level element instead of an inline element like text, which 
                    normally leaves a small gap below for descenders (such as “g” or “y”).*/
    margin-inline: auto; /* Centers the image. I didn’t use text-align for the header because setting 
                         display: block on #logo made the image a block-level element instead of an 
                         inline element. */
    padding-block: 2px;
    object-fit: contain; /* The height and width settings prevent the image from stretching out of shape, but 
                         they don’t tell the browser what to do if the image’s proportions don’t match the 
                         container’s shape. object-fit: contain scales the image so the entire image remains 
                         visible while preserving its aspect ratio, even if this leaves empty space within the 
                         container.*/
}

nav {
    border: .30px solid #89D6BB;
    background-color: rgba(137, 214, 187, 0.45);
    block-size: clamp(35.2px, 4%, 56px);
    display: grid; /* Replacing display: flex, flex-direction and justify-content with a flex grid. Both options 
                   work, but using a flex grid is cleaner and requires less code. Without display, the <ul> 
                   container reverts to the normal block flow, so the first child collapses/sits at the top by 
                   default, with its top edge touching the parent container’s top edge (losing margin). */
    place-items: center; /* Centers the child containers */
}

ul {
    display: flex;
    flex-flow: row wrap; /* Same as flex-direction: row; flex-wrap: wrap; */
    width: 100%; /* The <ul> container isn’t as wide as the parent <nav> container, so without this, 
                 justify-content won’t work. */
    justify-content: space-evenly;
    margin: 0; /* To make sure the content stays in the center even if the font size changes */
    padding: 0; /* To make sure the content stays in the center even if the font size changes */
    list-style-type: none;
}

@media (max-width: 520px) { /* For Mobile */
    nav {
        block-size: clamp(88px, 10%, 140px)
    }

    ul {
        display: flex;
        flex-direction: column;
    }

    ul li {
        margin: auto;
    }
}


nav ul li a {
    text-decoration: none;
    color: black;
    font-family: Garamond;
    font-size: 14px;
    text-shadow: .5px .5px 2px grey;
    transition: transform 450ms ease, color 450ms ease, box-shadow 450ms ease; 
}

nav ul li a:hover {
  transform: translate(0, -4px) scale(1.03);
  z-index: 2;
  color: #AFA2FC;   
}


main.home-page {
    flex: 1 1 auto; /* flex is a shorthand for flex-grow, flex-shrink, and flex-basis. flex-grow: 1 
                    means “if there’s extra space in the flex container, let this element grow to fill it,” 
                    while flex-shrink means “if there’s not enough space, allow this element to shrink.” 
                    This ensures that when the viewport becomes smaller, the main element can shrink before 
                    the layout overflows. flex-basis sets the element’s initial size before any growing or 
                    shrinking occurs, and auto means it uses the element’s natural size or any height or 
                    width that has been set.*/

    min-height: 0; /* This is very important for vertical layouts. By default, flex items have 
                   min-height: auto, which means the browser won’t let them shrink smaller than their content. 
                   Setting a different value allows the main element to shrink below its content if needed. */
    overflow: hidden;
}

.carousel {
    border: .40px solid #89D6BB;
    position:relative; /* The element stays in normal flow, but you can nudge it using top, left, right, or bottom. 
                       The space it originally occupied is still reserved — other elements don’t move into that space. 
                       Often used to create a positioning context for absolutely positioned child elements. */
    width: 100%;
    height: 100%;
    overflow: hidden;
}

.carousel > input[type="radio"] {
    position: absolute;
    opacity: 0; /* To make the dots invisible. The radio buttons in this scenario serve as separate stages 
                for the images. */
    pointer-events: none;
}

.carousel_viewport {
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: relative;
}

.carousel_track {
    display: flex;
    width: 300%;
    height: 100%;
    transition: transform 450ms ease; /* The transition property lets you animate changes to CSS properties over time — 
                                      instead of them happening instantly. The transform property visually manipulates an 
                                      element in 2D or 3D space — it can move, scale, rotate, or skew elements without affecting 
                                      surrounding layout flow. */
}

.carousel_slide {
    width:100%;
    overflow: hidden;
    padding: 0;
}

.carousel_slide > img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: contain;
}

.carousel_dots {
    position: absolute;
    display: flex;
    bottom: 1.5rem;
    left: 50%;
    transform: translateX(-50%);
    gap: 0.5rem;
    z-index: 2;
}

.carousel_dot {
  width: 6px; height: 6px; border-radius: 50%;
  background-color: black;
  cursor: pointer;
}


#s1:checked ~ .carousel_viewport .carousel_track { 
    transform: translateX(0%); 
}

#s2:checked ~ .carousel_viewport .carousel_track { 
    transform: translateX(-33.333%); 
}

#s3:checked ~ .carousel_viewport .carousel_track { 
    transform: translateX(-66.333%); 

}
footer {
    block-size: clamp(24.61px, 4%, 39.15px);
    background-color: rgba(137, 214, 187, 0.65);
}


main.our-story {
    position: relative;
    display: grid;
    gap: 2rem;
    grid-template-columns: 1fr 2fr;
    grid-template-rows: repeat(3, minmax(0, 1fr));
    grid-template-areas: "founder_img founder_body"
                         "mission_values_img mission_values_body"
                         "growth_achievements_img growth_achievements_body";
    flex: 1 1 auto; 
    min-height: 0;
    overflow: hidden;
}

#founder_img {grid-area: founder_img;}
#founder_body {grid-area: founder_body;}
#mission_values_img {grid-area: mission_values_img;}
#mission_values_body {grid-area: mission_values_body;}
#growth_achievements_img {grid-area: growth_achievements_img;}
#growth_achievements_body {grid-area: growth_achievements_body;}


.story_img, .story_section {
    margin: 0;
    min-height: 100%;
}


.story_img {
    outline: 2px dotted red;
    overflow: hidden;
    display: grid;  
    place-items: center;
}

.story_section {
    margin-left: 0;
}

h2 {
    font-family: Garamond;
    font-size: 14px;
}

p {
    font-family: Garamond;
    font-size: 10px;
}